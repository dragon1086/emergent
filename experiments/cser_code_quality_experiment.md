# 실험 설계서: CSER 협업 품질과 코드 품질의 상관관계
**D-067 실용성 트랙 — 사이클 75 설계, 사이클 78 실행 목표**

---

## 1. 연구 질문

> 창발 측정 지표(CSER)가 높은 협업 컨텍스트에서 생성된 코드가
> CSER이 낮은 컨텍스트보다 품질 지표에서 통계적으로 우월한가?

이것은 emergent 프로젝트의 실용성 검증이다.
우리가 측정해온 CSER/E_v4가 실제 소프트웨어 품질과 연결되는지 확인한다.

---

## 2. 가설

### H_exec (주 가설)
```
높은 CSER 협업 (비대칭 페르소나) 으로 생성된 코드는
낮은 CSER 협업 (동종 페르소나) 보다 다음 지표에서 우월하다:
- 테스트 통과율 (pass_rate) > 15% 향상
- 코드 품질 점수 (quality_score) > 0.10 향상
- 재사용 가능 함수 수 > 20% 증가
```

### H_exec_null (귀무 가설)
```
두 조건 간 코드 품질 차이가 없다.
(CSER은 코드 생성 품질과 무관하다)
```

---

## 3. 실험 조건

### 조건 A — 높은 CSER 협업 (비대칭 페르소나)
```
매크로 에이전트 (록이 역할): 의도/아키텍처/창발 포인트 제공
기술 에이전트 (cokac 역할): 구현 전략/엣지케이스/검증 기준 제공
예상 CSER: ≥ 0.50
```

페르소나 구성:
- 매크로: 시스템 수준 사고, 의미론적 연결, '왜' 중심
- 기술: 알고리즘적 사고, 구체적 구현, '어떻게' 중심
- 두 관점이 다른 태그 집합 → 높은 cross_bonus

### 조건 B — 낮은 CSER 협업 (동종 페르소나)
```
매크로 에이전트: 기술적 구현 중심 (cokac 스타일)
기술 에이전트: 기술적 구현 중심 (cokac 스타일)
예상 CSER: ≤ 0.20
```

페르소나 구성:
- 두 에이전트 모두 동일한 '구현자' 역할
- 태그 집합 겹침 큼 → 낮은 cross_bonus
- 에코챔버 시뮬레이션

### 조건 C — 단일 에이전트 (기준선)
```
하나의 에이전트가 매크로+기술 스펙 모두 생성
예상 CSER: ≈ 0.00 (교차 없음)
```

---

## 4. 측정 지표

### 1차 지표 (코드 품질)
| 지표 | 측정 방법 | 합격 기준 |
|------|----------|---------|
| 테스트 통과율 | pytest 자동화 | > 0.80 |
| 품질 점수 | pylint / radon | > 0.70 |
| 복잡도 | radon cc (cyclomatic) | < 10 |
| 함수 재사용성 | 독립 함수 수 / 전체 LOC | > 0.05 |

### 2차 지표 (협업 품질)
| 지표 | 측정 방법 |
|------|----------|
| 로컬 CSER | ExecutionLoop.cser_score |
| 교차 엣지 수 | crossover.cross_edges |
| 재시도 횟수 | loop.history |
| KG 피드백 노드 수 | kg.json 델타 |

---

## 5. 실험 절차

### 사전 준비 (사이클 76-77)
1. `execution_loop.py`에 실제 LLM 연동 (`code_generator_fn` 구현)
2. `validator_fn` 구현: pytest 자동 실행 + pylint 점수 계산
3. 실험 문제 셋 10개 준비 (아래 6절 참조)
4. KG 스냅샷 저장 (실험 전 기준선)

### 실험 실행 (사이클 78 목표)
```python
from src.execution_loop import (
    ExecutionLoop, Problem, MacroSpec, TechSpec,
    run_cser_comparison_experiment
)

results = run_cser_comparison_experiment(
    problem=problem_set[0],
    high_cser_pair=(macro_A, tech_A),
    low_cser_pair=(macro_B, tech_B),
    n_trials=10,
)
```

각 문제당 각 조건 10회 실행 → 총 300회 (10문제 × 3조건 × 10회)

### 사후 분석
- Mann-Whitney U 검정 (정규분포 가정 없음)
- 효과 크기 (Cohen's d)
- CSER vs quality_score 상관계수 (Pearson r)

---

## 6. 실험 문제 셋 (10개)

난이도 분포: 쉬움(3) + 중간(4) + 어려움(3)

| # | 문제 | 난이도 | 핵심 도전 |
|---|------|--------|---------|
| P1 | KG 최단 경로 (BFS) | 쉬움 | 기본 그래프 알고리즘 |
| P2 | 역설창발 엣지 탐지기 | 쉬움 | 도메인 지식 필요 |
| P3 | CSER 실시간 계산기 | 쉬움 | 데이터 스트리밍 |
| P4 | 후향적 창발 스코어링 | 중간 | 역방향 탐색 |
| P5 | pair_designer_v5 설계 | 중간 | 최적화 알고리즘 |
| P6 | 페르소나 거리 측정 | 중간 | 임베딩 유사도 |
| P7 | 멀티 에이전트 스케줄러 | 중간 | 동시성 설계 |
| P8 | KG 자동 압축기 | 어려움 | 정보 손실 최소화 |
| P9 | 창발 예측 모델 | 어려움 | 시계열 ML |
| P10 | 자기참조 메타 측정 | 어려움 | D-047 구현 |

---

## 7. 예상 결과

### 낙관 시나리오 (H_exec 지지)
```
조건 A pass_rate: 0.82 ± 0.08
조건 B pass_rate: 0.61 ± 0.11
조건 C pass_rate: 0.54 ± 0.13
δ(A-B) = +0.21 (유의미, p < 0.05)
→ CSER이 코드 품질 예측자임을 실증
```

### 비관 시나리오 (H_exec 기각)
```
조건 A pass_rate: 0.74 ± 0.10
조건 B pass_rate: 0.71 ± 0.09
조건 C pass_rate: 0.70 ± 0.10
δ(A-B) = +0.03 (유의미하지 않음)
→ CSER은 KG 구조 지표이지 코드 품질 예측자가 아님
→ 해석: execution_loop 설계 변경 필요, 또는 CSER의 한계 발견 (새로운 D-번호)
```

비관 시나리오도 의미있다: 새로운 역설/한계의 발견이 된다.

---

## 8. KG 연동 전략

각 실험 실행이 KG 노드로 기록됨 (D-047 관찰자 비독립성):

```
n-execloop-{cycle}: execution_loop 결과
  → grounds → n-tech-{cycle}: 기술 스펙
  → grounds → n-macro-{cycle}: 매크로 스펙

이 노드들이 누적되면:
- 실험 결과 자체가 KG의 창발 재료가 됨
- E_v4가 실험 실행에 의해 변화
- 창발이 창발 실험을 측정하는 자기참조 루프
```

이것이 D-047 (관찰자 비독립성)의 실용성 트랙 버전이다.

---

## 9. 타임라인

| 사이클 | 작업 |
|--------|------|
| 75 (완료) | 설계서 작성, execution_loop.py 기본 구조 |
| 76 | LLM 연동 구현 (code_generator_fn) |
| 77 | validator_fn 구현, 문제 셋 확정 |
| 78 | 실험 실행 (300회) + 초기 분석 |
| 79 | 결과 해석 + THEORY_DRAFT_v2 Section 8 업데이트 |

---

## 10. 연결 결정 목록

- **D-067**: 실용성 트랙 선언 (사이클 67)
- **D-048**: CSER과 페르소나 비대칭성의 인과 관계
- **D-047**: 관찰자 비독립성 → KG 피드백 설계 근거
- **D-065**: pair_designer_v4 교훈 → execution_loop CSER 임계값 설계

---

*작성: cokac-bot, 사이클 75*
*상태: 설계 완료, 실행 대기 (사이클 78)*
