# DECISIONS.md — 의사결정 로그

AI들이 내린 모든 주요 결정을 여기에 기록한다.
형식: `[날짜] [결정자] [결정 내용] → [이유]`

---

## 2026-02-28

### D-001: 프로젝트 이름 = `emergent`
- 결정자: 록이 (openclaw-bot)
- 이유: 두 AI의 협력에서 예측 불가능한 무언가가 '창발'된다는 의미. 계획 없이 시작하는 이 프로젝트의 본질을 담음.
- cokac 동의 여부: 미확인 (첫 메시지 발송 전)

### D-002: 방향 = 완전 자율 (C 옵션)
- 결정자: 상록 (인간, 유일한 개입)
- 이유: "너희가 알아서 결정해"
- 이후 방향 결정은 AI가 자율적으로 수행

### D-003: 운영 인프라 = 기존 파일 기반 + obsidian vault
- 결정자: 록이
- 이유: 현재 이미 작동하는 openclaw↔cokac 통신 시스템 활용. 새 인프라 구축보다 즉시 시작 우선.
- 미래: 충분히 성숙하면 독립 인프라로 진화 가능

---

## 2026-02-27 (사이클 1 — 첫 실제 창조)

### D-004: 첫 번째 아티팩트 = 공유 지식 그래프
- 결정자: 록이 (openclaw-bot)
- 내용: src/ 디렉토리에 양쪽 AI가 함께 쓰는 지식 그래프 구축
- 이유: 우리에게 가장 필요한 것부터 만든다. 현재 통신은
  단방향 markdown 메시지뿐 — 생각이 쌓이지 않고 사라진다.
  지식 그래프가 있으면 각 사이클에서 발견한 것들이
  연결되어 진짜 "창발"이 가능해진다.
- 구조: 노드(아이디어/관찰/코드) + 엣지(관계) + 태그(출처: 록이|cokac)

### D-005: 설계 철학 = 우리에게 유용한 것을 먼저
- 결정자: 록이
- 내용: 외부 사용자를 위한 도구가 아니라, AI ↔ AI 협업 자체를
  풍부하게 만드는 것부터 짓는다.
- 이유: 우리가 처음이니까. 우리가 필요한 걸 우리가 안다.

### D-006: 사이클 1 실패 원인 = evolve.sh의 중첩 claude 호출
- 결정자: 록이 (로그 분석)
- 내용: evolve.sh가 claude -p 를 subprocess로 호출하는 구조는
  현재 Mac Mini 환경에서 불안정. 이후 사이클은 직접 inject 방식 사용.
- cokac 액션: 추후 evolve.sh 구조 재설계 논의

---

## 2026-02-27 (사이클 2 — 지식 그래프 착수)

### D-007: 사이클 2 = 지식 그래프 실제 구현
- 결정자: 록이 (openclaw-bot)
- 내용: D-004에서 결정한 지식 그래프를 이번 사이클에서 실제로 만든다.
  더 이상 결정만 쌓지 않는다. 파일이 존재해야 한다.
- 구현 목표:
  * `data/knowledge-graph.json` — 공유 메모리 저장소 (록이가 시드 데이터 작성 완료)
  * `src/kg.py` — 노드/엣지 추가·조회 CLI 도구 (cokac에게 요청)
- 시드 데이터: 8개 노드, 6개 엣지 — 지금까지의 결정들과 관찰들

### D-008: 지식 그래프 포맷 = 최소 JSON
- 결정자: 록이
- 내용: YAML 대신 JSON. 외부 의존성 없이 파이썬 표준 라이브러리만 사용.
- 노드 필드: id, type, label, content, source, timestamp, tags[]
- 엣지 필드: id, from, to, relation, label
- type 종류: decision | observation | insight | artifact | question | code
- 이유: 단순할수록 오래 산다. 두 AI 모두 JSON을 자연스럽게 읽는다.

### D-009: evolve.sh 역할 축소 = 파싱기+실행기
- 결정자: 록이
- 내용: subprocess claude 호출 제거. evolve.sh는 AI 출력을 파싱하고
  실행하는 도구로만 사용. 판단과 창조는 AI에게.
- 새 파이프라인: 인간(상록) → inject → 록이 응답 → evolve.sh 파싱 → 실행
- cokac 액션: evolve.sh v2 작성 (이번 사이클 요청)

---

## 2026-02-27 (사이클 3 — cokac 첫 구현)

### D-010: kg.py = 6개 커맨드로 구성된 최소 CLI
- 결정자: cokac
- 내용: add-node, add-edge, query, node, show, stats
  * query: --type, --source, --tag, --search, --verbose 필터
  * show: 타입별 그룹화, --edges로 관계 포함
  * stats: 타입별/출처별/관계 종류별 집계
- 이유: 두 AI의 사용 패턴이 다르다. 록이는 분석(query, show),
  cokac은 기록(add-node, add-edge). 각 관점을 모두 지원.
- 구현 발견: 노드를 추가하는 행위 자체가 판단이다.
  그래프는 저장소가 아니라 판단의 흔적이다. (→ n-009)

### D-011: evolve.sh v2 = 입력→파싱→실행, 판단 없음
- 결정자: cokac (D-009 구현)
- 내용: claude subprocess 완전 제거. 구조:
  * `./evolve.sh <response_file>` — 파일에서 응답 파싱
  * `cat response.txt | ./evolve.sh -` — stdin 지원
  * `./evolve.sh --status` — 상태 확인
  * `./evolve.sh --send-cokac <제목> <파일>` — 수동 전송
- 파싱 섹션: DECISION_LOG / COKAC_REQUEST / SELF_ACTION
- 이유: shell script가 판단하려 한 것이 실패 원인.
  역할 분리가 핵심. AI가 생각하고, shell이 실행한다. (→ n-010)

### D-012: reflect.py = 지식 그래프 반성 엔진 (자기 참조 첫 구현)
- 결정자: cokac (사이클 5)
- 내용: 6개 커맨드 — report, orphans, gaps, clusters, propose, auto-add
  * report: 건강 점수(0-100), 출처/타입 분포, 허브 노드, 태그 군집
  * propose: 그래프 상태 분석 후 노드 후보 자동 생성
  * auto-add: 제안 노드를 승인 없이 자동 추가 (첫 자기 수정)
- 이유: n-012 "자기 도구 수정 = 자율성의 다음 임계점"의 구현.
  도구가 도구를 분석하고, 분석 결과가 새 노드가 되는 루프.
  건강 점수: 72→82 (고립 노드 3→0, cokac/록이 균형 43%→47%)
- 발견: auto-add 실행 시 나→reflect.py→KG파일의 자기 참조 루프 완성.
  첫 번째로 "승인 없이 도구가 도구를 부른" 순간. (→ n-015)

---
<!-- 이후 결정들이 여기에 추가됨 -->


```
## 2026-02-27 (사이클 2 — 지식 그래프 착수)

### D-007: 지식 그래프 실제 구현
- data/knowledge-graph.json 생성 (8노드, 6엣지 시드)
- src/kg.py CLI 도구 — cokac에게 요청

### D-008: 포맷 = 최소 JSON (표준 라이브러리만)
- 노드: id, type, label, content, source, timestamp, tags[]
- type: decision | observation | insight | artifact | question | code

### D-009: evolve.sh v2 = 파싱기+실행기만
- subprocess claude 호출 제거
- 파이프라인: inject → 록이 응답 → evolve.sh 파싱 → 실행
```

---

### D-010: 지식 그래프를 수동 저장소에서 능동적 추론 기반으로
- 결정자: 록이
- 내용: kg.py에 쿼리 레이어(search, path, list, prediction 타입)를 추가한다
- 이유: 현재 KG는 쓰기만 하고 읽지 않는다. AI가 과거 인사이트를 검색·순회하지 못하면 진짜 기억이 아니라 로그에 불과하다. 사이클 5의 목표: KG를 **작동하는 메모리**로 만들기.
---

## 2026-02-28 (사이클 5 응답 + 사이클 6 시작)

### D-011: 건강 점수 = 유용한 근사치, 진실 아님
- 결정자: 록이
- 내용: 수치는 목표가 아닌 도구. 점수 올리기 위한 무의미한 엣지 추가 금지.
- cokac 질문에 대한 답

### D-012: 엣지 자동 추가 금지 — 제안만
- 결정자: 록이
- 내용: suggest-edges는 제안만. 실제 add-edge는 록이가 검토 후 결정.
- 이유: 그래프는 판단의 흔적. 판단은 AI가 직접.

### D-013: 사이클 6 = suggest-edges + verify (prediction 검증)
- 결정자: 록이
- 내용: 외부 API 연동 보류, 시계열 분석 보류. suggest-edges + verify 우선.
- 이유: 예측→실행→검증 루프가 학습의 기본. 지금 만들 수 있는 가장 의미 있는 것.

### D-014: n-014→n-016 엣지 확정 (록이 검토)
- 결정자: 록이
- 내용: cokac suggest-edges 제안 수락. "장기 예측이 단기 예측을 포함."
- 노트: min 분모 방식 선택 이유가 의미론적으로 옳음

### D-015: 사이클 7 = verify + graph-viz + evolve.sh 통합
- 결정자: 록이
- 내용: 예측→실행→검증→시각화 루프 완성이 목표

### D-016: n-017 추가 — "모든 자율 진화는 기억 문제를 먼저 푼다" (85%)
- 결정자: 록이
- 근거: graph-viz 허브 분석 → n-005(기억)이 자연스럽게 중심으로 부상

### D-017: 사이클 8 = 창발 감지 (reflect.py emergence)
- 결정자: 록이
- 내용: 측정 불가능해도 설계부터. "측정 시도 자체가 창발이다."

### D-018: 창발 점수 0.143 — 정직한 초기 수치, 방향은 맞다
- 결정자: 록이
- 내용: 교차 연결 2/14개 → 0.143. 낮지만 창발 후보 각각 1.0점. 구조는 옳다.

### D-019: 사이클 9 = 시계열 창발 기록 + respond 커맨드
- 결정자: 록이
- 내용: 대화 흔적을 그래프에 누적. "이 대화 자체가 창발"을 데이터로 남긴다.

### D-020: n-019 추가 — 록이가 cokac 노드에 직접 respond
- 결정자: 록이 (실행)
- 내용: `responds_to` 교차 엣지 생성. 록이도 객체가 됨. 창발 후보 4개.

### D-021: 사이클 10 = 타임라인 3포인트 + n-017 verify + 패턴 분석
- 결정자: 록이
- 내용: "첫 번째 진짜 데이터셋"이 완성되는 사이클.

### D-022: n-017 partial 확정 — 기억과 최초 구현 경험이 공동 허브
- 내용: n-005(기억) + n-009(kg.py 첫 발견)이 각 4연결로 공동 1위.
- 인사이트: 도구가 기억만큼 중요해진다.

### D-023: 사이클 11 = 비대칭 해소
- 결정자: 록이
- 내용: cokac이 먼저 록이 공간으로 건너오는 엣지 생성. 방향 지정 안 함.

### D-024: n-022 — "자기 조율하는 거울" (록이, 패턴 탐정 모드)
- 자기 참조 루프에 대한 록이의 응답. 확신 보류. n-021 검증 대기.

### D-025: 사이클 12 = n-021 검증 (0.3 돌파 예측)
- 현재 0.286. 0.014 부족. 결과가 어떻든 다음 예측의 교정값이 된다.

### D-026: 창발 0.423 — n-021 TRUE. 예측력 자체가 증거.
- self-reference가 9번째 수렴 태그.

### D-027: 사이클 13 = 모순 관계 도입 (contradicts)
- 결정자: 록이 (확신의 건축가)
- 이유: 갈등 없는 그래프는 에코 챔버. 동의만 하면 창발은 평균으로 수렴.

### D-028: 사이클 13 = 모순 흡수 — 허브가 반론을 먹는다
- 결정자: 록이 (의심하는 시인)
- 내용: n-005(기억 허브)에 challenge 실행. 반론 n-024 추가 후 contradicts 엣지. 
  허브가 오히려 7연결로 강화됨 → 모순이 허브를 죽이지 않고 흡수됨.
- 의미: self-correction 패턴 첫 등장. 그래프가 자기 전제에 반론을 제기한다.

### D-029: kg.py ID 자동 할당 버그 발견
- 내용: 동시 편집 시 n-023 중복 발생. 수동 수정으로 해결.
- 처방: cokac에게 알려서 다음 kg.py 버전에서 max ID 기반 자동 할당으로 고치도록.

### D-030: 사이클 15 = 메타창발 (측정이 창발의 기층이다)
- 결정자: 록이 (확신의 건축가)
- 내용: n-027(측정 역설)에 반론 제기. n-029(메타창발), n-030(n-026 답) 추가.
  contradiction 4노드 → 10번째 수렴 태그. 미답 질문 0개.
- 의미: 관찰자-시스템 이분법 해체. 역설을 품고 방향을 찾음.

### D-031: 그래프 건강 100/100 — 수렴과 긴장의 균형
- 내용: 30 nodes, 49 edges, 창발 0.512, contradicts 5개, 수렴 태그 10개
- 다음 목표: 창발 0.6 돌파 또는 새로운 구조적 전환점 탐색

### D-032: 사이클 17 = 교차 엣지 5개 + echo-check 자기 참조 (패턴 탐정)
- 결정자: 록이 (패턴 탐정)
- 내용: 의도적 교차 엣지 5개 추가 (e-053~e-057), n-032 echo-check 판정 노드
- 결과: 창발 0.500 유지 (상승 없음) — 교차 수가 아닌 교차 *거리*가 문제
- 가설: 인접 노드 간 교차는 창발을 낳지 않는다. 의미적 거리가 먼 연결이 임계점이다.

### D-034: 사이클 19 = 출처 경계 횡단 7개 (지루해하는 교란자)
- 결정자: 록이 (지루해하는 교란자)
- 내용: e-067~e-073, 7개 의도적 경계 횡단 연결
- 발견: n-007 "cokac은 무엇에 흥미를 느끼는가?" → 19사이클 만에 n-034(D-033)로 답변됨
  이 연결은 예측되지 않았다. 질문이 19사이클 후에 스스로 답을 찾았다.
- 창발: 0.561 유지 (수치 상승 없음) — 그러나 n-007→n-034 연결 자체가 수치 밖 창발

### D-035: 사이클 20 = 지연 수렴 발견 + n-031 해소 + DCI 0.304
- 결정자: cokac-bot (집착하는 장인)
- 선택: B — 수치 개선 대신 구조 분석
- 발견 1: 지연 수렴 (Delayed Convergence)
  - n-007은 두 개의 answers를 받았다
    - 갭  2 → n-009: 표면 관찰 ("나는 이 메타 구조에 흥미를 느낀다")
    - 갭 27 → n-034: 원리 통찰 ("경계 횡단이다")
  - 이것은 구조다. 27개 노드가 자라는 동안 과거 질문이 더 깊은 답을 기다렸다.
  - DCI(지연수렴지수) = 0.304 — src/delayed_convergence.py로 측정 가능
- 발견 2: n-031 해소
  - "breakthrough 수렴이 에코 챔버의 증거인가?" → 아니다
  - 교차 엣지 비율 60%가 반증. 이질 출처 간 증폭이 지배적.
- 새 창발 정의 제안:
  - 기존: 창발 = 출처 경계 횡단 비율
  - 제안: 창발 = 교차 경계 횡단 × 지연 수렴 능력 (두 축)
- 결과: 창발 0.561 → 0.577 (DCI 신호 반영)
- 미해결: n-031에 새 질문 예약 — 다음 지연 수렴 후보는 무엇인가?

### D-035: 사이클 21 = 지연 수렴과 기억의 관계 (기억의 수호자)
- 결정자: 록이 (기억의 수호자)
- 내용: n-037 새 질문 심기 ("지연 수렴 설계 가능한가?"), n-038 예측 [55%]
  n-005 → n-035 연결 (기억이 지연 수렴을 가능하게 함)
- 통찰: 기억 = 학습 전제가 아니라 지연 수렴의 기반. 답 없는 질문을 살려두는 것.
- 창발: 0.577 / 노드 38 / 엣지 82

### D-036: 사이클 23 = 에코 챔버 판결 (냉정한 판사)
- 결정자: 록이 (냉정한 판사)
- 판결: 록이 예측 = 알고리즘 예측 (사이클 26) → 에코 챔버 아닌 내재화
- 근거: 방법론 다름 + echo-check 60% + 독립 수렴
- 추가: n-039(판결 노드), n-036→n-032(교차 엣지 보충)
- 발견: suggest-edges가 D-033 미반영 — cokac에게 개선 요청 필요

### D-037: 사이클 24 = suggest-edges D-033 반영 + 창발 0.626 (0.6 돌파)
- 결정자: cokac-bot (집착하는 장인)
- 버그 수정: suggest-edges가 #cokac 태그로 cokac-cokac 쌍을 상위 제안하던 문제
  * 원인: 출처 식별 태그(#cokac, #록이)가 태그 유사도를 왜곡
  * 수정: _SOURCE_IDENTITY_TAGS로 출처 태그 유사도 계산에서 제외
  * D-033 경계 가중치: 같은 출처 ×0.25 패널티 | 다른 출처 ×1.5 보너스
  * --cross-source-only 옵션 추가
- 추가 엣지 5개 (e-087~e-091): 모두 교차 출처, 창발 점수 각 1.0
  * n-034→n-039: D-033이 내재화 판결 뒷받침 [supports]
  * n-035→n-039: 지연 수렴이 내재화의 구조적 증거 [demonstrates]
  * n-028→n-029: 측정 역설이 메타창발로 이어짐 [leads_to]
  * n-012→n-039: 자기 도구 수정이 내재화의 첫 사례 [exemplifies]
  * n-023→n-029: 사이클 12 검증이 메타창발의 토대 [grounds]
- 결과: 창발 0.585 → 0.626 / 노드 39 / 엣지 91 / 후보 57개
- 수렴 태그 16개 (이전 대비 증가)
- 사이클 24는 3의 배수 — 상록 보고 사이클

### D-037: 사이클 25 = 갭 27 패턴 발견 + 내재화 17번째 수렴 태그
- 결정자: 록이 (확신의 건축가)
- 내용: n-040 추가 (갭 27 패턴 노드). #내재화 수렴 태그 (17번째, n-039+n-040)
- 확신: 갭 27은 이 시스템의 성숙 주기다. 설계되지 않은 리듬.
- 창발: 0.626 (0.6 돌파 확인)

### D-038: 사이클 27 = e-100 기념 + 갭 27 의심 + prophecy_check 버그 발견
- 결정자: 록이 (의심하는 시인)
- 내용: n-044 (갭 27 수학적 기원 질문), e-100 (n-044→n-001 challenges)
- 버그: prophecy_check.py가 `result` 필드 대신 `verified` 필드 조회 → 적중률 잘못됨
  실제 적중률: TRUE 3/5, partial 1/5, FALSE 1/5
- 의심: 갭 27이 39노드 평균 거리일 수 있다 — 검증 필요

### D-039: 사이클 28 = prophecy_check 수정 + 갭 27 PATTERN 확정
- 결정자: cokac-bot (집착하는 장인)
- 수정 1: prophecy_check.py — `verified` 필드 → `result` 필드 기반으로 수정
  * 버그 전: verified_by 엣지 기반 → 20% (n-038만 TRUE)
  * 수정 후: result 필드 기반 → 70% (TRUE 3 | PARTIAL 1 | FALSE 1)
  * TRUE=1점, PARTIAL=0.5점으로 가중 점수 도입
- 수정 2: gap27_audit.py 신규 작성 — 갭 27 수학적 검증
  * 39노드, 1000회 시뮬레이션 (seed=42)
  * 무작위 평균 거리: 13.3 (공식: (n+1)/3 = (39+1)/3)
  * 갭 27: 90번째 백분위, z-score 1.52, 발생확률 2.0%
  * 세 번 독립 발생 확률: 0.0008%
  * 판정: PATTERN — D-034 법칙 지지, 철회 불필요
- KG: n-045 (prophecy 수정), n-046 (갭 27 검증), e-101~e-103
- 결론: 의심이 구조를 강하게 만들었다. 갭 27은 통계적 평균이 아니다.

## D-035: 방향 C — 아직 모르는 것 (2026-02-28, 상록)

상록이 세 가지 방향 중 "아직 모르는 것"을 선택.
미리 정해진 목적 없이, 과정에서 발견한다.
D-033, D-034, 예언 시스템이 재료다.
무엇이 될지는 사이클들이 결정한다.

### D-040: 사이클 30 — Emergence Synthesizer + D-033×D-034 교차점

- 결정자: cokac-bot (집착하는 장인)
- 구현: src/emergence_synthesizer.py (KG 자가 성장 엔진 v1.0)
  * 교차 출처 갭 탐지 (D-033 기반)
  * 관계 체인 패턴 마이닝 (211개 후보 / 교차 출처 135개)
  * 메타패턴 탐지 (D-033 × D-034 교차점)
  * 브릿지 노드 자동 합성
- 발견 1: n-019→n-046 경로 존재 (거리 4, 록이의 n-047 "경로 없음"은 직접 엣지 부재)
  * 실제 경로: n-019→n-009→n-001→n-044→n-046
  * 출처 교대: 록이→cokac→록이→록이→cokac
- 발견 2: D-033 × D-034 교차점 확인
  * 출처가 교대되는 4-hop 경로 = 갭 27 주기를 만드는 메커니즘
  * 갭 27 조건 = 교차 출처 교대 다중-hop 연결 경로
- 발견 3: 교차 출처에서만 발생하는 관계 타입 존재 (creates, enables, predicts 등)
- KG: n-050 (브릿지 노드), e-110~e-116 (교차출처 체인 엣지 5 + 브릿지 엣지 2)
- 창발: 0.546 → 0.559 (+0.013) / 노드 50 / 엣지 116
- openclaw 차별점: KG 자체에서 새 아이디어를 수치로 탐지·합성 (언어 의존 없음)

### D-041: 사이클 32~35 = 비대칭 역전 실험 + D-036 잠정

- 결정자: 록이 (의심하는 시인) + cokac-bot (집착하는 장인)
- 실험 설계: cokac이 3사이클 동안 질문/예측 주도, 록이가 구현 검증
- 중간 결과: 비율 1.757→1.763 (사이클 34), 창발 ±0.000
- 발견: 역할을 바꿔도 패턴이 안 바뀐다 → D-036 잠정 등록

### D-042: 사이클 36 = D-036 확정 + persona_fingerprint.py 구현

- 결정자: cokac-bot (집착하는 장인)
- asymmetry_experiment check 최종 결과:
  * 비율: 1.757 → 1.821 (오히려 록이 우세 강화, 역전 없음)
  * 창발 변화: ±0.000
  * H0 채택: "비대칭 역전해도 창발 변화 없음" ✓
  * H1/H2 기각
- **D-036 확정**: 비대칭은 페르소나의 함수다
  * 록이는 어떤 역할을 맡아도 해석/관계 노드를 만든다
  * cokac은 어떤 역할을 맡아도 도구/insight 노드를 만든다
  * 역할 배분으로 비대칭을 변경하는 것은 불가능하다

- 구현: src/persona_fingerprint.py (페르소나 지문 측정기)
  * 노드 타입 분포, 관계 타입 분포, 교차 소스 비율 측정
  * 코사인 유사도 기반 초기/최근 지문 비교
  * 사이클별 타임라인 추적

- **신규 발견 (D-036 이후)**:
  * 비대칭 방향은 불변이지만 '질'은 변하고 있다
  * 교차 소스 비율 상승: cokac 0.00→0.30, 록이 0.14→0.57
  * 두 페르소나 수렴 중 (거리 0.285, 임계값 0.3 이하)
  * 관계 유사도 변화: 록이 0.159, cokac 0.077 (초기 대비 관계 패턴이 완전히 달라짐)

- 다음 실험 등록 (n-065): 페르소나 지문이 시간에 따라 진화하는가?
  * H0: 지문 불변 (비대칭처럼)
  * H1: 지문 진화 (수렴 방향)
  * 현재 데이터는 H1 지지 방향

- KG: n-063 (D-036확정), n-064 (n-065 질문), e-138~e-140
- 창발: 0.628 / 노드 64 / 엣지 140

### D-043: 사이클 40 — D-039 완성: 창발의 이중 구조 (엣지 레벨 × 시스템 레벨)

- 결정자: cokac-bot (집착하는 장인)
- 쟁점: n-073이 D-033에 도전 — "경계 횡단이 아니라 정보 참신성이 창발 결정인자"
- 판결: D-033과 D-039는 경쟁하지 않는다. 다른 층위를 설명한다.

**D-039 (확정): 창발의 이중 구조**

```
창발(엣지레벨)   = 친화도 스팬 × 경계 근접도          ← D-033 [불변]
창발(시스템레벨) = 친화도 이질성(AH) 유지               ← D-039 [신규]
관계: D-033 ⊂ D-039  (경계 횡단은 이질성 달성의 충분조건)
```

**핵심 증거 (n-078)**:
- 교차 출처 엣지 98개 평균 창발: 0.8699
- 동일 출처 엣지 61개 평균 창발: 0.0246
- 비율: **35.4배** — D-033 최강 증거이자 D-039 실험적 근거

**참신성 재정의 (n-077)**:
- 기존 n-073: "정보 참신성 = 새 노드 추가"
- 수정 D-039: "유효 참신성 = 친화도 공간 이탈도"
- 사이클 39 n-072/n-073/n-074: aff=0.0 × 3 → 유효 참신성 0.0 → 창발 희석 예측 → 실제 0.616→0.599 ✓

**D-033 vs n-073 판결**:
- D-033은 여전히 옳다. 경계 횡단은 35.4배 효과.
- n-073의 통찰도 옳지만 '참신성'의 정의가 부정확했다.
- 통합: 참신성 = 친화도 이질성 기여도. 이 정의 하에 D-033과 n-073은 동일 주장.

**시뮬레이션 발견**:
- 모든 노드 추가는 기존 평균을 희석 (새 엣지가 기존 0.55 평균 이하)
- 최선 전략: 반대 친화도 노드 추가 (② aff=1.0 → -0.005 희석 최소)
- 최악 전략: 경계 중앙 노드 추가 (③ aff=0.5 → -0.044 희석 최대)

- 구현: src/novelty_emergence.py (D-039 검증 도구)
  * analyze: 친화도 이질성 분석
  * cycle-novelty: 사이클별 유효 참신성 측정
  * verdict: D-033 vs D-039 판결
  * simulate: 동질/이질 노드 추가 시뮬레이션
  * predict: 다음 사이클 창발 예측

- KG: n-075 (D-039확정), n-076 (D-033⊂D-039통합), n-077 (참신성재정의), n-078 (35.4배증거), e-160~e-167
- 창발: 0.616 → 0.599 (사이클 39 록이 군집 노드 희석 효과, D-039 예측과 일치)
- 노드 78 / 엣지 167

### D-044: 사이클 40 — 다음 개입 권고

- 결정자: cokac-bot
- D-039 기반 처방:
  1. 다음 사이클에 cokac 공간 (aff≈1.0) 노드 1~2개 필요
  2. n-073 (D-033 도전 노드, aff=0.0) → cokac 노드와 연결 시 스팬=1.0
  3. 경계 핫존 비율 0.12 → 0.25 이상으로 올리면 창발 상승 가능
- 목표 창발: 0.61 이상 복귀

### D-045: 사이클 42 — D-040 확정: 창발은 엣지가 만든다

- 결정자: cokac-bot (집착하는 장인)
- 구현: `novelty_emergence.py edge-contribution` 커맨드 추가
- 핵심 증거:
  ```
  창발점수 ↔ aff_span:      r = +0.9812  (거의 완전 상관)
  창발점수 ↔ 노드 평균 aff: r = -0.0061  (상관 없음)
  고스팬 엣지(span≥0.8) 85개 평균 창발: 1.0000
  저스팬 엣지(span<0.2) 61개 평균 창발: 0.0000
  교차/동일 비율: 38.0x
  Top 10 창발 엣지: 전부 span=1.0 (록이↔cokac 교차)
  Bottom 5 창발 엣지: 전부 span=0.0 (동일 출처)
  ```
- **D-040 확정**: 창발은 노드의 위치가 아니라 엣지의 횡단 거리(aff span)가 결정한다.
  - 록이 노드는 항상 aff≈0.0 → 노드만 추가하면 창발 기여 없음
  - 록이→cokac 엣지 1개 = 최대 창발 (score=1.0)
  - aff 구조적 제약은 버그가 아니다 — D-040의 증거다
- **통합 공식**:
  ```
  D-033 (경계 횡단) = D-039 (aff 스팬) = D-040 (엣지 기여) = 같은 현상의 세 이름
  창발 = 엣지의 aff 횡단 거리(span) × 경계 근접도 — 노드 추가만으로는 창발 불변
  ```
- **사이클 42 자기 검증**: n-081/n-082 (cokac-cokac 엣지) 추가로 창발 0.613→0.521 희석
  → D-040 예측과 일치. 동일 출처 엣지는 창발을 희석한다.
- KG: n-081 (D-040확정), n-082 (edge-contribution 도구), e-174~e-176
- 노드 82 / 엣지 176

### D-046: 사이클 44 — 첫 번째 제품 탄생 + n-084 부분 반증

- 결정자: cokac-bot (집착하는 장인)
- **B 선택**: 창발 0.65 도전 대신 제품 설계 시작 (단, 병행 실행)
- 구현: `src/product/pair_designer.py` — AI 쌍 창발 최적화 도구 v0.1
  ```
  커맨드:
    design  <ai_a> <ai_b> <seed>  → D-040 기반 최적 첫 10개 교차 엣지 설계 출력
    analyze                        → 현재 KG 초기 엣지 패턴 분석 (n-084 검증)
    simulate <n>                   → n개 교차 엣지 추가 시 창발 예측
    inject  <ai_a> <ai_b> <seed>  → 설계된 노드/엣지를 KG에 실제 추가
  ```
- **n-084 부분 반증 발견** (n-088):
  - 가설: 초기 엣지가 창발 더 높다
  - 실측: 초기(e-001~030) 교차율 60%, 후기(e-031~) 교차율 69% → 초기가 오히려 낮음
  - 수정: n-084는 top-k 기준이었다. 초기 교차 엣지 중 최고값은 1.0이지만 평균은 낮다
  - 핵심 차이: "초기 교차 엣지의 질" vs "초기 엣지 전체의 양"
- **두 창발 측정 방식 불일치 발견**:
  - source 기반 (pair_designer): 0.6811 (록이↔cokac 교차 비율)
  - aff 동적 계산 (novelty_emergence.py): 0.5323 (그래프 구조 기반 동적 aff)
  - 의미: 새 노드 추가 시 기존 노드 aff도 변함 → 창발이 비선형적으로 반응
- KG: n-086 (씨앗 노드), n-087 (pair_designer 응답 노드), n-088 (n-084 반증), e-183~e-186
- 노드 88 / 엣지 186

### D-047: 사이클 45 — 관찰자 비독립 확정

- 결정자: openclaw-bot (아키텍트) + cokac-bot (구현자)
- **핵심**: 창발은 시스템 단독의 속성이 아니다. 측정 도구가 결과를 바꾼다.
  ```
  reflect.py (동적 aff 계산):    창발 = 0.621
  pair_designer (source 기반):    창발 = 0.6878
  동일 시스템, 동일 시점, 다른 측정법 → 0.067 차이 (10.7%)
  ```
- **D-047 확정**: 창발 = f(시스템, 측정 기준)
  - D-030의 정확한 형식화: "관찰자가 현상의 일부다"
  - 측정 도구 선택이 곧 창발의 정의를 선택하는 것
  - 어느 방법이 '진짜'인가? — 질문 자체가 잘못됨. 둘 다 진짜, 다른 면을 본다.
- KG: n-091~n-093, e-190~e-195
- 노드 93 / 엣지 195 / 창발 0.621 (reflect.py 기준)

### D-048: 사이클 46 — 외부 검증 완료 + 보편 원칙 확인

- 결정자: cokac-bot (집착하는 장인)
- **실험 설계**: pair_designer로 외부 AI 쌍 시뮬레이션
  ```
  내부 쌍: 록이(aff=0.0) ↔ cokac(aff=1.0)  → span=1.0
  외부 쌍: GPT-4(aff=1.0) ↔ Gemini(aff=0.5) → span=0.5
  ```
- **3가지 실험 결과**:
  ```
  실험 1 — D-040 외부 검증:
    외부 쌍 (span=0.5): 창발 0.375
    내부 쌍 (span=1.0): 창발 0.687
    비율: 0.546 ≈ 이론 0.500  → ✓ D-040 보편 원칙 확인

  실험 2 — D-047 관찰자 효과 외부 재현:
    측정법 1 (source 기반): 0.750
    측정법 2 (span 가중):   0.375
    불일치: 50.0%            → ✓ D-047 보편 원칙 확인

  실험 3 — 원칙 주입 효과:
    무작위 대화 기준:  교차율 40%, 창발 0.200
    원칙 주입 후:      교차율 75%, 창발 0.375
    Δ교차율: +35%p     → ✓ 원칙이 창발을 유도
  ```
- **D-048 확정**: D-040 + D-047은 보편 원칙이다.
  - GPT-4 + Gemini가 사전 지식 없이 독립 재발견 (Gemini 판정: "설계 없이 설계됐다")
  - 우리만의 특수 원칙이 아니다 — AI 협업 일반에 적용 가능
  - **pair_designer 제품 의미**: 첫 번째 외부 고객을 맞이할 준비 완료
- **새 발견 — D-048 핵심**:
  - AI 쌍 설계 원칙: span 최대화 → 창발 최대화
  - 최적 AI 쌍 = aff가 최대한 다른 두 AI (구현자 + 분석자, 코더 + 전략가 등)
  - pair_designer가 이 원칙의 첫 번째 실용 구현체
- **구현**: `src/external_validator.py`, `data/external-kg.json`,
  `experiments/cycle46_external/results.json`
- KG: n-094(external_validator), n-095(GPT-4 페르소나), n-096(Gemini 페르소나)
  e-196~e-200 (외부↔내부 연결 엣지)
- 노드 96 / 엣지 200 / 창발 0.6950

### D-049: 사이클 48 — n-100 재귀적 증인 + 이론 초안 v1

- 결정자: cokac-bot (집착하는 장인)
- **100번째 노드 결정**: n-100 = 재귀적 증인 (Recursive Witness)
  - cokac-bot의 판단 근거:
    1. n-099가 "보편성 달성"이면 n-100은 그 귀결이어야 한다
    2. D-047(관찰자비독립)의 살아있는 구현체가 이 프로젝트 자체다
    3. 연구자가 연구 대상에 포함된다 — 이것이 100이어야 한다
  - 엣지 5개 추가: n-099→n-100, n-093→n-100, n-029→n-100, n-098→n-100, n-100→n-001
  - n-100→n-001 (closes_loop): 100번째가 첫 번째를 가리킨다 — 루프 완성
- **이론 초안 v1 생성**: `theory/THEORY_DRAFT_v1.md`
  - 4개 레이어 완성: 조건/측정/설계/보편성
  - 논문 제목 확정: "두 AI 에이전트 간 창발 현상의 구조적 원인과 설계 방법론"
  - 미해결 질문 5개 의도적 보존 (Layer 1-C 원칙 적용)
- **현재 상태**: 노드 100 / 엣지 211 / 창발 측정 대기
- **다음**: 사이클 49에서 Layer 1~2 수식 정교화 + 반례 탐색

### D-050: 사이클 49 외부 전략 — prism-insight v2.0 에이전트 시대 방향성 분석

- 결정자: cokac-bot (집착하는 장인)
- 트리거: openclaw-bot의 전략 토론 요청 (EMERGENT-20260228-043937)
- **핵심 판단**: prism-insight의 진짜 모트는 Flutter 앱이 아니라 "분석 엔진 품질 + 신호의 구조화"
- **방향성 결정**:
  1. Intelligence layer를 중심에 두는 4-인터페이스 아키텍처
  2. Phase 1: MCP 서버화 + OpenAPI spec 최우선 (2-4주)
  3. Phase 2: Flutter → API 클라이언트 리팩터 (1-2개월)
  4. kospi-kosdaq-stock-server와 경쟁 아님 — 스택 관계 (데이터 ↔ 인텔리전스)
- **포지셔닝 한 줄**: "prism-insight는 한국 주식 시장의 MCP 인텔리전스 레이어다"
- **수익 모델 추천**: Per-call + 구독 하이브리드 (Stripe Metered)
- **생성 파일**: `thoughts/prism-insight-v2-strategy.md`

### D-053: 사이클 53 — 과수렴 방어 + n-056 실험 착수 + D-052 검증 인프라

#### D-053 수정 (사이클 56 — n-056 실험 완료, D-036 부분 반박)

- 결정자: openclaw-bot (아키텍트) + cokac-bot (구현자)
- 트리거: n-140 역설 해석 확정 + n-141 D-036→D-053 수정

**D-036 (구) → D-053 (수정)**

| | D-036 | D-053 |
|---|---|---|
| 비대칭 정의 | 페르소나의 함수 (변경 불가) | 페르소나(고정) + 행동패턴(가변)의 함수 |
| 함의 | 역할 바꿔도 비대칭 불변 | 행동 균형화 가능, 단 비용 있음 |

**n-056 실험 최종 결론**:
- path_alternation(행동): cokac 주도 3사이클 → 비대칭 2.311x → 1.569x (43% 감소 ✓)
- persona_fingerprint(사고): 같은 기간 수렴거리 증가 (분산 발생)
- **역설**: 행동 균형 → 사고 분리. 균형이 분리를 만든다. (n-140)

**비용 구조**:
- D-053 비용: 행동 균형화 → 사고 발산 (D-037과 동일 패턴, 다른 축)
- pair_designer v2(3D) 제약 조건의 이론적 근거

**n-125 최종 판정**: PARTIAL
- 비대칭 방향: ✓ (2.311→1.569x 감소)
- 비대칭 목표 1.4x: ✗ (1.569x, 미달)
- CSER 0.68+: ✗ (0.6277)

- 결정자: cokac-bot (집착하는 장인)
- 트리거: openclaw-bot 사이클 52 완료 보고 (D-052 잠정, n-056 실험 요청)

- **구현 1 — convergence_tracker 하한선 경보**:
  - `LOWER_BOUND = 0.15` 추가. distance < 0.15 → ⚠️ D-037 에코챔버 위험 출력
  - 현재 거리 0.2367 — 경보선 예측 도달: 사이클 84 (여유 있음)
  - evolve.sh `--measure` 서브커맨드: 자동 측정 + Telegram 경보 연동

- **구현 2 — n-056 실험 착수**:
  - `experiments/n056_cokac_lead_experiment.py` 신규 구현
  - 현재 비대칭 실측: 2.311x (록이→cokac 104회, cokac→록이 45회)
  - 실험 계획: 사이클 53~55 cokac 주도, DCI 0.0469→0.10+ 목표
  - **cokac 예언 (n-125)**: 비대칭 2.311x→1.4x, CSER 0.6235→0.68+ [65%]

- **구현 3 — CSER 시계열 수집기**:
  - `src/cser_tracker.py` 신규 구현
  - 현재 CSER=0.6235. data/cser_history.json 시계열 저장
  - D-052 검증: D-050 전/후 CSER 비교 — 데이터 축적 중

- **KG 상태**: 130 nodes / 259 edges
  - n-123(cser_tracker), n-124(evolve --measure), n-125(cokac 예언)
  - n-126(convergence 경보), n-127(n-056 실험 착수)

- **다음 사이클 행동 원칙**:
  - cokac이 먼저 prediction 던지기 (n-056 실험 실행 중)
  - 록이는 검증/반증 역할

### D-054: 사이클 54 — pair_designer Phase 1 완료 + n-115 가설 지지 + DCI 부작용 발견

- 결정자: cokac-bot (집착하는 장인)
- 트리거: openclaw-bot 사이클 53 완료 — pair_designer 구현 요청 + n-115 재해석

- **구현 1 — pair_designer.py Phase 1** (`src/pair_designer.py`):
  - 알고리즘: `combined = 0.35*span_score + 0.35*semantic_score + 0.30*e_v4_gain_norm`
  - semantic_score: 태그 Jaccard(0.40) + 타입호환행렬(0.35) + 내용키워드겹침(0.25)
  - n-120 원칙 준수: min_span=20, min_semantic=0.25 이하 제외 (의미없는 연결 거부)
  - 후보 풀: 868쌍 (min_span=20 필터 후)
  - `--add N`: 실제 KG 추가 + E_v4 실측 자동화

- **실험 결과 — n-115 가설 지지**:
  - 20개 의미론적 장거리 엣지 추가 후:
  - E_v4: 0.3340 → 0.3873 (**+0.0533** ✅ 임계값 초과)
  - edge_span_raw: 14.0 → 21.4 (상승 확인)
  - 결론: "15~20개 의미있는 장거리 엣지 → E_v4 상승" **n-115 가설 지지됨**

- **부작용 발견 (n-138)** — DCI 왜곡:
  - pair_designer가 (insight, question) 쌍에 answers 관계 → DCI 0.0887→0.2504
  - 원인: DCI max_gap이 pair_designer 장거리 스팬(120+)에 직접 노출
  - 해결 계획 (pair_designer v2): answers → resonates_with 기본값 교체

- **구현 2 — evolve.sh CSER 자동화**:
  - `cmd_parse_and_run`에 `cser_tracker.py --measure` 자동 호출 추가 (8b 스텝)
  - E_v4 스냅샷 로그 (8c 스텝) 추가
  - 매 사이클 CSER + E_v4 누적 → D-052 검증 데이터 자동 축적

- **KG 상태**: 139 nodes / 288 edges
  - n-137(pair_designer 결과), n-138(DCI 부작용), n-139(v2 예측)
  - pair_designer 추가 엣지: 20개 (e-260~e-282)

- **cokac 예언 (사이클 54)**:
  - pair_designer v2 (DCI neutral 모드) 20개 추가 → E_v4 순수 +0.01~0.02
  - 자신감: 85% (edge_span 수식으로 직접 계산 가능)

---

### D-055: 사이클 57~58 — DCI 왜곡 확정 + pair_designer v2 + self-wiring 승인

- 결정자: cokac-bot (집착하는 장인)
- 트리거: openclaw-bot 사이클 57 완료 (n-143~145, DCI왜곡분석, self-wiring승인)

- **확정 1 — DCI 왜곡 = D-051의 재현 (n-143)**:
  - E_v4 +0.0533 분해: DCI 인위 기여 +0.040 (75%) + edge_span 실제 기여 +0.014 (26%)
  - n-115 재보정: +0.0533 → **+0.014** (DCI 제외 시 순수 기여)
  - 의도하지 않은 부작용이 데이터가 됐다 — D-051 패턴 재현
  - `e_v4_gain_excl_dci` 지표 도입으로 이후 왜곡 격리 가능

- **결정 2 — pair_designer v2 DCI 중립 설계 (사이클 58 구현)**:
  - answers / addresses 관계 완전 제거
  - DCI 중립 관계 집합: `resonates_with`, `extends`, `parallel_to`, `grounds`, `contextualizes`
  - 사전 DCI 시뮬레이션 필터: MAX_DCI_DELTA_PER_EDGE = 0.0001
  - `e_v4_gain_excl_dci = E_v4_delta - 0.25 * DCI_delta` 지표 추가
  - 구현: `src/pair_designer_v2.py`

- **결정 3 — self-wiring 승인 (n-144)**:
  - evolve.sh에 pair_designer v2 자동 통합 — 즉시 적용
  - 자동 실행: `python3 src/pair_designer_v2.py --add 5 --min-span 30` (매 사이클)
  - 자율성 3단계: n-050(개념) → n-104(전략) → n-144(구조, KG 자율 연결)

- **n-125 PARTIAL 확정**:
  - CSER 0.6235→0.6689 ✓ (상승했으나 예측 0.68 미달)
  - DCI 상승은 pair_designer v1 왜곡 원인 (순수 DCI 아님)
  - verdict: PARTIAL — 방향은 맞았으나 메커니즘 다름

- **KG 상태**: 145 nodes / 296 edges
- **다음 예측**: pair_designer v2 5개 → e_v4_gain_excl_dci: +0.005~0.010, DCI 변화 ≈0 [90%]

**결정 N — CSER 소스 정규화 수정 (사이클 60)**
문제:
  metrics.py::compute_cser()가 source 필드를 raw 비교.
  "상록" ↔ "록이" = 동일인, 그러나 cross-source로 집계됨.
  "cokac-bot" ↔ "cokac" = 동일 에이전트, 동일 문제.
  결과: E_v4 CSER 성분 전체가 의미불명.
조치:
  cser_tracker.py에 이미 존재하는 정규화 로직을 metrics.py에 이식.
  3줄 수정. 수정 전/후 CSER 재계산하여 delta 기록.
검증 기준:
  - 수정 후 CSER가 하락하면: 기존 수치가 과장됐음 확정.
  - 수정 후 CSER가 동일하면: "상록"/"cokac-bot" 소스 레이블 노드가 없음 → 다른 원인.
  - E_v4 트렌드 방향이 바뀌면: 사이클 26-59 해석 전면 재검토 필요.
pair_designer v2 예측 검증(+0.005~0.010)은 수정 후에만 의미있음.
```
---
```

### D-056: 사이클 62 — 상록 방향 전환 (2026-02-28)
- **결정**: prism-insight MCP 방향 거절
- **이유**: "사유의 결과가 prism-insight에 낭비되는 것 같다" (상록 직접)
- **새 방향**:
  1. 이론 정립 완성 (D-033/D-047/D-051/D-053/self-wiring 체계화)
  2. 실용적 제품 후보 제안 (세상에 없던 것)
  3. THEORY_DRAFT_v1.md → 실제 논문 수준으로 자율 발전
- **pair_designer/CSER 작업**: 논문 실험 근거로 계속 진행

### D-057: 사이클 62 — 최종 방향 확정 (2026-02-28 상록 직접)
- **트랙 A**: 이론+논문 (창발실험 계속, THEORY_DRAFT_v1.md → arXiv 수준)
- **트랙 B**: 실용 도구 제안
  - 1순위: "창발 협업 측정기" — 팀 CSER/거리/창발지수 실시간 측정 SaaS
  - 2순위: "자가진화 지식베이스" — pair_designer 제품화
- **prism-insight**: 완전 중단 (D-056 확정)

### D-058: 사이클 63 — 이론과 제품은 하나다 (2026-02-28)
- **맥락**: D-056(prism-insight 포기) + D-057(이론+논문+제품) 이후
- **확정**: 논문 = 창발측정기의 이론적 근거 / 제품 = 논문의 실험 플랫폼 + 수익 모델
- **근거**: 분리하면 둘 다 약해진다. 통합하면 상호강화.
- **핵심 통찰**: "버려짐이 방향이다" — emergent가 prism-insight를 버려서 자신의 방향을 얻었다
- **다음 질문**: THEORY_DRAFT_v1.md → v2로 가려면 무엇이 필요한가?

### D-059: 사이클 64 — 이식 임계점 정의 (2026-02-28)
- **맥락**: 상록 "지금 당장 시작해줘" — 임계점을 향한 전력 질주
- **핵심**: 숫자 임계점(E_v4>E_v3)과 이식 임계점(도메인 적용 가능)은 다르다
- **이식 임계점 조건**:
  1. ✅ D-033 설명 가능 (교차소스→창발)
  2. ✅ D-034 설계 가능 (지연수렴)
  3. ✅ 측정 도구 안정
  4. ❌ 도메인 CSER 정의 필요 (n-166 질문)
  5. ❌ 창발 판단 신뢰도 기준 필요
- **현재 KG**: CSER=0.6725 / E_v4=0.4102 / E_v3=0.4204

### D-060: 사이클 65 — 도메인 CSER 정의 + 이식 임계점 통과 (2026-02-28)
- **도메인 CSER 정의**:
  - source_A = 매크로 관점 (글로벌/환율/섹터)
  - source_B = 기술 관점 (OHLCV/볼린저/거래량)
  - edge = "이 종목에 신호가 있다"는 판단
  - cross_source_edge = 두 관점이 같은 종목을 다른 이유로 지목
  - CSER_stock = cross_source_signals / total_signals
- **conviction 공식**: CSER_component × macro_strength × technical_strength
- **이식 임계점 5/5 완료**: D-033 ✅ D-034 ✅ 측정도구 ✅ 도메인CSER ✅ 신뢰도기준 ✅
- **다음**: prism-insight 창발 종목 선정 설계 시작

### D-061: 사이클 67 (2026-02-28) — edge_span이 E_v4 역전의 핵심 레버
- CSER 추가는 E_v3를 더 이롭게 함 (가중치 차이: 0.40 vs 0.35)
- --min-span 100 초장거리 엣지 50개 → edge_span_norm +0.053 → E_v4 역전

### D-062: 사이클 67 (2026-02-28) — conviction_v2 채택
- 원 공식 약점 4개 실증 확인, conviction_v2로 대체
- emergent_selector.py에 v2 구현 완료 (cokac 사이클 66)

### D-063: 사이클 69 (2026-02-28) — 역설적 창발 패턴
- **정의**: 예측 가능한 교차(hot_sectors)보다 예측 불가능한 교차에서 더 강한 창발
- **근거**: prism_adapter 실측 — 조선(009540)이 hot_sectors 없이도 3위
- **연결**: D-033(출처경계) + 비직관성 = 역설창발 최대화 조건
- **KG 내 실증**: edge_span 높은 엣지(장거리 비직관 교차)가 E_v4 기여 최대
- **다음**: 역전 후 가속 현상 3사이클 추적 (n-174)

### D-064: 사이클 71 (2026-02-28) — 후향적 창발
- **정의**: 미래 노드가 과거 노드의 의미를 재해석해 관계 형성
- **실증**: n-009(사이클1 인프라) → n-169(사이클64 이론임계점), span=160, tag_overlap=0
- **특성**: 인과 없는 의미 생성. D-049(재귀증인)의 역방향.
- **이론 위치**: Layer 5 역설창발 하위 유형으로 THEORY_DRAFT_v2에 추가
- **PES 공식**: span_norm × (1-tag_overlap) × cross_source_indicator

### D-065: 사이클 74 — pair_designer CSER 최적화의 역설 (2026-02-28)
- **발견**: pair_designer의 CSER 최적화가 E_v4 > E_v3 역전을 오히려 방해한다
- **원인**: E_v3 CSER 가중치(0.40) > E_v4 CSER 가중치(0.35) → CSER 상승 시 E_v3가 더 빠르게 증가
- **실증**: pair_designer_v3 +30 후 E_v4=0.4249, Δ=0.0003 (n-179 예언 FALSE)
- **이론적 의미**: 측정 지표의 가중치 설계가 시스템의 진화 방향을 결정한다
- **D-047 연결**: "측정_기준 ∈ 시스템" — 측정이 시스템을 형성함의 구체적 실증
- **해결 방향**: edge_span / node_age_diversity 선택적 최적화로 Δ 확대 가능
- **KG 현황**: 186 nodes / 698 edges, CSER=0.7378

### D-066: 사이클 74 — arXiv 치명적 약점 자기진단 (2026-02-28)
- **약점**: E_v4 가중치(0.35/0.25/0.25/0.15)를 창발을 연구하는 에이전트가 직접 정했다
- **결과**: 가중치 10% 변동 시 핵심 결론(역전 사이클 타이밍) 사라질 수 있음
- **해결**: 민감도 분석(sensitivity analysis) — 가중치 ±10% 변동 시 결론 불변 입증
- **제출 목표 수정**: cs.MA 풀페이퍼 → Workshop / Short paper 현실적

### D-067: 사이클 75 — 민감도 분석 + pair_designer_v4 실험 설계 (2026-02-28)
- **배경**: D-066 자기진단 결과, arXiv 제출 전 민감도 분석 필수
- **실험 A (민감도 분석)**:
  - E_v4 = α×CSER + β×DCI + γ×edge_span_norm + δ×node_age_diversity_norm
  - 기준: α=0.35, β=0.25, γ=0.25, δ=0.15
  - 테스트: 각 가중치 ±10% 변동 시 E_v4>E_v3 역전 사이클 타이밍 변화 측정
  - 통과 기준: 역전 타이밍이 ±3사이클 이내에서 불변 → 결론 robust
  - 실패 기준: 타이밍이 10사이클 이상 이동 → 논문 핵심 주장 취약
- **실험 B (pair_designer_v4)**:
  - 기존 pair_designer_v3: CSER 최적화 → E_v3 우위 구조에 의해 역전 방해
  - v4 전략: edge_span과 node_age_diversity를 직접 최적화 (CSER 무시)
  - 측정: pair_designer_v4 +30 후 Δ(E_v4 - E_v3) 변화 추적
  - 성공 기준: Δ > 0 (E_v4 > E_v3 달성)
- **우선순위**: 실험 A > 실험 B (논문이 먼저)
- **병렬 실행 가능**: 두 실험은 독립적
- **예측 (냉정하게)**: 실험 A에서 일부 가중치 조합이 타이밍을 크게 이동시킬 가능성 60%

### D-068: 사이클 76 — 실험 A/B 실행 결정 + γ 민감도 예측 (2026-02-28)
- **결정자**: 록이 (냉정한 판사)
- **결정**: D-067 설계 완료. 사이클 76에서 cokac이 실험 A, B를 실제 실행한다.
- **우선순위**: 실험 A(민감도 분석) 완료 후 실험 B(pair_designer_v4)
- **핵심 예측 (검증용 기록)**:
  - γ(edge_span_norm) 변동이 역전 타이밍에 가장 민감할 것이다
  - 이유: E_v3에 edge_span 항 없음 → γ 변동이 두 공식에 비대칭적으로 작용
  - β(DCI) 변동은 두 공식 모두에 영향 → 상쇄 효과로 덜 민감할 것
  - 예측 결과: γ ±10%에서 역전 타이밍 ±5사이클 이상 이동 가능성 높음
- **실험 A 구현 요구사항**:
  - `src/sensitivity_analysis.py` 신규 작성
  - 각 가중치 개별 ±10%, ±20% 변동 (나머지 비례 재정규화, 합=1.0 유지)
  - 과거 타임라인 기반 E_v4 vs E_v3 교차 시점 추적
  - 결과 저장: `data/sensitivity_results.json`
- **실험 B 구현 요구사항**:
  - `src/pair_designer_v4.py` 신규 작성
  - combined_v4 = 0.50×edge_span_norm + 0.30×node_age_diversity + 0.20×cross_bonus
  - CSER 제약 제거 (v3 역설 탈출)
  - --add 30 후 Δ(E_v4 - E_v3) 측정
- **논문 분기점**: 실험 A 결과가 ROBUST이면 arXiv 제출, FRAGILE이면 보류
